/*----------------------------------------------------------------------------*/
/* Copyright (c) 2015-2019 FIRST. All Rights Reserved.                        */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

//#include <hal/HALBase.h>

#include "gtest/gtest.h"
#include "wpi/WebSocketServer.h" 
#include "wpi/SmallString.h"

#include <wpi/json.h>
#include <wpi/uv/Loop.h>
#include <wpi/uv/Tcp.h>
#include <wpi/uv/Stream.h>
#include <wpi/raw_ostream.h>
#include <wpi/uv/util.h>

class WebServerIntegrationTest : public ::testing::Test {
private:
  std::shared_ptr<wpi::uv::Loop> m_loop;
  std::shared_ptr<wpi::uv::Tcp> m_tcp_client;
  std::shared_ptr<wpi::uv::Stream> m_stream;

public:
  bool createClient() {
    //auto self = this->shared_from_this();

    m_loop = wpi::uv::Loop::Create();
    if(!m_loop) {   
      return false;
    }

    m_tcp_client = wpi::uv::Tcp::Create(m_loop);
    if(!m_tcp_client) {
      return false;
    }


    struct sockaddr_in dest;
    wpi::uv::NameToAddr("localhost", 8080, &dest);
    m_tcp_client->Connect(dest, [this, socket = m_tcp_client.get()]() {
        auto ws = wpi::WebSocket::CreateClient(*m_tcp_client, "/wpilibws", "localhost:8080");
        ws->closed.connect([&](uint16_t code, wpi::StringRef reason) {
          //Finish();
          if (code != 1005 && code != 1006)
            FAIL() << "Code: " << code << " Reason: " << reason;
        });
        ws->open.connect([&, s = ws.get()](wpi::StringRef) {
          //++gotClientOpen;
          s->Close();
        });
        ws->text.connect([this](wpi::StringRef msg, bool) {
          wpi::json j;
          try {
            j = wpi::json::parse(msg);
          } catch (const wpi::json::parse_error& e) {
            std::string err("JSON parse failed: ");
            err += e.what();
            wpi::errs() << err << "\n";
            //ws->Fail(1003, err);
            return;
          }
        });
      });

    m_loop->error.connect(
      [](wpi::uv::Error err) { wpi::errs() << "uv Error: " << err.str() << "\n"; });

    // Hook up TCP client events
    m_tcp_client->error.connect(
      [this, socket = m_tcp_client.get()](wpi::uv::Error err) {
        m_loop->Stop();
        return;
      });

    m_tcp_client->closed.connect(
      []() { wpi::errs() << "TCP connection closed\n"; });

    // Set up the connection timer
    // m_connect_timer = wpi::uv::Timer::Create(m_loop);

    return true;
  }

  bool sendMessage(const wpi::json & msg) {

  }
};


/*

class WebServerIntegrationTest : public ::testing:Test {
public:
  static const char* pipeName;

  static void SetUpTestCase();

  WebServerIntegrationTest() {
    loop = uv::Loop::Create();
    clientPipe = uv::Pipe::Create(loop);

#if 0
    auto debugTimer = uv::Timer::Create(loop);
    debugTimer->timeout.connect([this] {
      std::printf("Active handles:\n");
      uv_print_active_handles(loop->GetRaw(), stdout);
    });
    debugTimer->Start(uv::Timer::Time{100}, uv::Timer::Time{100});
    debugTimer->Unreference();
#endif

    auto failTimer = uv::Timer::Create(loop);
    failTimer->timeout.connect([this] {
      loop->Stop();
      FAIL() << "loop failed to terminate";
    });
    failTimer->Start(uv::Timer::Time{1000});
    failTimer->Unreference();
  }

  ~WebSocketTest() { Finish(); }

  void Finish() {
    loop->Walk([](uv::Handle& it) { it.Close(); });
  }

  static std::vector<uint8_t> BuildHeader(uint8_t opcode, bool fin,
                                          bool masking, uint64_t len);
  static std::vector<uint8_t> BuildMessage(uint8_t opcode, bool fin,
                                           bool masking,
                                           ArrayRef<uint8_t> data);
  static void AdjustMasking(MutableArrayRef<uint8_t> message);
  static const uint8_t testMask[4];

  std::shared_ptr<uv::Loop> loop;
  std::shared_ptr<uv::Pipe> clientPipe;
  std::shared_ptr<uv::Pipe> serverPipe;
};
};

TEST_F(WebSocketIntegrationTest, Open) {
  int gotServerOpen = 0;
  int gotClientOpen = 0;

  serverPipe->Listen([&]() {
    auto conn = serverPipe->Accept();
    auto server = WebSocketServer::Create(*conn);
    server->connected.connect([&](StringRef url, WebSocket&) {
      ++gotServerOpen;
      ASSERT_EQ(url, "/test");
    });
  });

  clientPipe->Connect(pipeName, [&] {
    auto ws = WebSocket::CreateClient(*clientPipe, "/test", pipeName);
    ws->closed.connect([&](uint16_t code, StringRef reason) {
      Finish();
      if (code != 1005 && code != 1006)
        FAIL() << "Code: " << code << " Reason: " << reason;
    });
    ws->open.connect([&, s = ws.get()](StringRef) {
      ++gotClientOpen;
      s->Close();
    });
  });

  loop->Run();

  ASSERT_EQ(gotServerOpen, 1);
  ASSERT_EQ(gotClientOpen, 1);
}

TEST(WebServerExtention, DigitalOutput) {
  //HALSIM_SetDIOValue(0, false);
  
  // TODO compare received value on client
  // {"type":"DIO","device":"0","data":{"<>value":false}}
  ASSERT_EQ(0,0);
}

TEST(WebServerExtention, DigitalInput) {
  // TODO:
  // 1) Register as input: HALSIM_SetDIOIsInput(0, true)
  // 2) Verify client receives: {"type":"DIO","device":"0","data":{"<input":true}}
  // 2) Send value from client: {"type":"DIO","device":"0","data":{"<>value":false}}
  ASSERT_EQ(0,0);
}
*/
int main(int argc, char** argv) {
/*  HAL_Initialize(500, 0);
  
  WSRegisterFunc registerFunc = [&](auto key, auto provider) {
    providers.Add(key, provider);
  };

  //HALSimWSProviderAnalogIn::Initialize(registerFunc);
  //HALSimWSProviderAnalogOut::Initialize(registerFunc);
  HALSimWSProviderDIO::Initialize(registerFunc);
  //HALSimWSProviderDigitalPWM::Initialize(registerFunc);
  //HALSimWSProviderDriverStation::Initialize(registerFunc);
  //HALSimWSProviderEncoder::Initialize(registerFunc);
  //HALSimWSProviderPWM::Initialize(registerFunc);
  //HALSimWSProviderRelay::Initialize(registerFunc);
  //HALSimWSProviderRoboRIO::Initialize(registerFunc);
  
  wpi::ws::client?

  HALSIM_GetDIOValue(m_channel)
  */
  ::testing::InitGoogleTest(&argc, argv);
  int ret = RUN_ALL_TESTS();
  return ret;
}